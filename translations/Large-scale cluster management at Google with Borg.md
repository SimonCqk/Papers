### 摘要

`Google Borg`是一个横跨多个集群（单个集群的机器数可达数万台），运行着成百上千不同应用任务的集群管理系统。
它通过进程级别的性能隔离，将准入控制，高效的任务打包，存储过度分配以及机器资源共享，糅合在一起以达到高利用率。它还具备最小化的故障恢复时间，
配置调度策略以降低相关故障率等运行时特性，来支持应用的高可用。`Borg`提供了描述式作业规范语言，命名（域名）服务集成，实时任务监控等系统行为分析与仿真工具来简化用户的工作。
我们将总结一下过去十余年对`Borg`系统的架构，特性，重要的设计决定，一些决策的分析和测试的经验。

### 1.介绍

我们内部称之为`Borg`的集群管理系统，管理，调度，启动，重启并监视了所有的`Google`应用。本文将会解释它是怎么做到的。
`Borg`提供了三大好处：（1）隐藏了资源管理和故障处理的细节，因此它的用户可以专注应用开发。（2）本身即高可靠/高可用，因此在其之上的应用也是。（3）让我们的工作负载高效地分摊到成千上万的机器上。`Borg`并不是第一个解决此类问题的系统，但它是极少数能够以如此高弹性和高完成度处理这种规模的系统之一。本文将围绕这些主题，通过我们十余年的经验得出一些定性的结论（观察）。

### 2.用户角度

`Borg`的用户是`Google`应用及服务的开发者或SRE。用户以作业`(jobs)`的形式提交他们的任务`(task)`，每个job由一个或多个的二进制程序组成。每个job运行在单个`Borg cell`上，管理的最小单元是一些机器的集合。这个章节将描述Borg展示给用户视角的一些主要特性。

### 2.1 Workload（工作负载）

`Borg cell`主要运行着两大异构的工作负载。第一部分是长时运行的服务（在线任务），主要处理短时且延迟敏感的请求（从几微秒到几百毫秒）。这些服务面向终端用户，例如`Gmail，Google Docs，Google search`，也用于内部的一些基础设施服务，例如`BigTable`。第二部分是处理时长从几秒到几天不等的批处理任务（离线任务），这些任务对短期的性能波动并不敏感。工作负荷在cells上的比例不同，依赖于它们的租期（某些cell的任务是高度密集的），并且在时间维度上这些任务的跨度也非常大：批处理任务来来去去，并且很多面向终端用户的服务处于昼夜不停的使用模式中。Borg需要平等地处理以上所有状况。
一个代表性的`Borg` 负载例子是一个公开的2011年5月整月的记录数据集，并且它已经得到了充分的分析。
过去几年已经有很多应用框架在`Borg`之上被建立起来了，包括我们内部的`MapReduce，FlumeJava，MillWheel，Pregel`等。这些中的大多数都有一个控制器来提交主job和一些工作job，`MapReduce`和`FlumeJava`扮演了与YARN应用管理者相似的角色。我们的分布式存储系统`GFS`，以及它的后继`CFS`，还有`BigTable，Megastore`都跑在`Borg`上。
在此文中，我们把高优先级的`Borg job`划分为"`production (prod) job`"，其余为"`non-production (non-prod) job`"。在一个具有代表性的cell中，`prod jobs`占据了大约70%的CPU资源以及大约60%的CPU利用率，同时占据了55%的总内存和85%的内存利用率。

### 2.2 Clusters and cells（集群和单元）

同一个cell里的机器都属于单个集群，通过数据中心级的高性能网络光缆连接在一起。一个集群存活在单个数据中心的建筑中，多个建筑构成了一个站点。一个集群通常只有一个cell，但是可能会有一些小型的用于测试的cell和其他有特殊用途的cell。我们竭尽所能地避免任何的单点故障。
我们的除去测试cell之后的中心cell规模大约有1万台机器，甚至有些更大。一个cell中的机器在多个维度都是异构的：大小（CPU，RAM，硬盘，网络），处理器类型，性能和IP地址的容量或闪存介质。`Borg`通过这些维度的差异将不同用户隔离开来并决定task被分配到哪个cell上运行，获取资源，安装程序及其依赖，监视它们的健康状况，并在他们异常退出时重启。

### 2.3 Jobs and tasks（作业和任务）

一个`Borg job`的属性包括名字，拥有者和它所包含的task数目。Jobs可以通过常量去约束它的tasks运行在特定属性的机器上，比如处理器架构，OS版本或是一个外部IP地址。常量可以是硬性的也可以是弹性的。弹性的指可以作为偏好设置而不是要求。一个job的启动可以延迟到前一个job结束，一个job只能运行在一个cell中。
每个task映射到运行着容器的Linux进程集合中。绝大部分的Borg xxx不运行在虚拟机上，因为我们不想承担硬件虚拟化的巨大开销。并且，这个系统是在我们xxx没有支持虚拟化的硬件。
Task也有它的属性，比如资源需求和它在job中的索引。同一个job中的大多数task有着相同的属性，但也可以被xxx，例如通过命令行参数。每个资源维度（CPU核数，RAM，硬盘空间，硬盘读写速率，TCP端口等）都被独立地指定。Borg程序为了减少对运行时环境的依赖，都采用静态链接，并且被组织成由二进制程序和数据文件组成的包，它们的安装都可以xxx Borg。
用户通过调用RPC来操作jobs，通常通过命令行工具，其他Borg job或是监视系统来完成。大多数job的描述通过xxx配置语言BCI完成。BCI是GCL的变种，它会生成protobuf文件并通过Borg指定的关键字来拓展。GCL提供lambda函数来进行计算，并且被应用用来调整配置和环境。有数万的BCL文件超过1k行，因此我们已经有了超过1千万行的BCL。Borg job的配置和Aurora配2置文件有很多相同之处。
用户可以通过向Borg推送一份新的job配置文件来更改一个正在运行当中的job中的所有task，并且命令Borg更新有新指示的所有任务。这些操作都被视为是一种轻量级的，非原子性的事务，那么当然它们在被关闭（提交）之前也可以轻易撤销。xxxxxxxx一句。
一些task的更新操作（例如推送一个新的二进制文件）总是会触发重启，一些（例如对资源的需求数增长或改变了常量）会使得task不再适应于当前的机器，然后导致它被停止然后重新调度，还有一些（例如更改优先级）总是可以无需重启或移动而被完成。
Task可以请求在被kill之前通过 Unix SIGTERM信号机制得到通知，从而有时间完成扫尾，保存状态，结束当前正在执行的请求并拒绝新请求等操作。xxxxxxxx一句。

2.4 Allocs
例如MapReduce的master上的task比worker节点上的任务优先级稍高一些，为的就是提高master的可靠性。优先级直接反映了cell中正在运行或者正在等待的job的重要程度。Quota被用于调度哪个job来xxx。在一个给定的优先级的一段时间内（通常是数月），quota用一个包含资源数的向量（CPU，RAM，硬盘灯）来表示——资源数置顶了一个用户job某时可以请求的最大资源数。
