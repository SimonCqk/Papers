### 摘要

Google Borg是一个横跨多个集群（单个集群的机器数可达数万台），运行着成百上千不同应用任务的集群管理系统。
它通过进程级别的性能隔离，将权限管理，高效的任务打包，xxxx以及机器资源共享，糅合在一起以达到高xx。它还具备最小化错误恢复时间，
配置调度策略以降低相关错误率等运行时特性，来支持应用的高可用。Borg提供了xx任务语言，命名服务集成，实时任务监控等系统行为分析与仿真工具来简化用户的工作。

1.介绍
我们内部称之为Borg的集群管理系统，管理，调度，启动，重启并监视了所有的Google应用。本文将会解释它是怎么做到的。
Bory提供了三大好处：（1）隐藏了资源管理和错误处理的细节，因此它的用户可以专注应用开发。（2）本身即高可靠/高可用，因此在其之上的应用也是。（3）让我们的工作负载高效地分摊到成千上万的机器上。Bory并不是第一个解决此类问题的系统，但它是极少数能够以如此高的xx和完成度处理这种规模的系统之一。本文将围绕这些主题，通过我们十余年的经验得出一些xx的结论（观察）。

2.用户角度
Borg的用户是Google应用及服务的开发者或SRE。用户以jobs的形式提交他们的任务，每个job由一个或多个的二进制程序组成。每个job运行在单个Borg cell上，管理的最小单元是一些机器的集合。这个章节的xxx描述了Borg暴露给用户视角的一些主要特性。
2.1 工作负荷
Borg cell以两大部分运行着xxxx的工作负荷。第一部分是长时运行的服务（在线任务），主要处理短时且延迟敏感的请求（从几微秒到几百毫秒）。这些服务面向终端用户，例如Gmail，Google Docs，搜索，也用于内部的一些基础设施服务，例如BigTable。第二部分是处理时长从几秒到几天不等的批处理任务（离线任务），这些任务对短期的性能xx并不敏感。工作负荷与cell混合在一起，cell依靠他们的xxx运行着不同的应用（某些cell的任务是高度密集的），并且在时间维度上这些任务的跨度也非常大：批处理任务来来去去，并且很多面向终端用户的服务xxxx。Borg需要平等地处理以上所有状况。
一个很有代表性的Bory workload 例子可以在2011年5月开始的一段长达一月的公开跟踪中找到，并且它已经被用来充分分析了。
过去几年已经有很多应用框架在Borg之上被建立起来了，包括我们内部的MapReduce，FlumeJava，MillWheel，Pregel等。这些中的大多数都有一个控制节点来提交主job和一些工作job，MapReduce和FlumeJava扮演了和YARN应用管理者相似的角色。我们的分布式存储系统GFS，以及它的xxx CFS，还有BigTable，Megastore都跑在Borg上。
在此文中，我们把高优先级的Borg job划分为"production (prod) job"，其余为"non-production (non-prod) job"。在一个具有代表性的cell中，prod jobs占据了大约70%的CPU资源以及大约60%的CPU利用率，同时占据了55%的总内存和85%的内存利用率。

2.2  Clusters and cells
同一个cell里的机器都属于单个集群，通过高性能的数据中心规模的网络光缆连接在一起。一个集群存活在单个数据中心的建筑中，多个建筑构成了一个站点。一个集群通常只有一个cell，但是可能会有一些小型的用于测试的cell和其他有特殊用途的cell。我们xxx避免任何的单点错误。
我们的除去测试cell之后的中心cell规模大约有1万台机器，甚至有些更大。一个cell中的机器通过多个维度被xxx：大小（CPU，RAM，硬盘，网络），处理器类型，性能和IP地址的容量或闪存容量。Borg通过这些维度的差异将不同用户隔离开来并决定任务被分配到哪个cell上运行，获取资源，安装程序及其依赖，监视它们的健康状况，并在他们异常退出时重启。

2.3 Jobs and tasks
一个Borg job的属性包括名字，拥有者和它所包含的task数目。Jobs可以通过常量去约束它的tasks运行在特定属性的机器上，比如处理器架构，OS版本或是一个外部IP地址。常量可以是硬性的也可以是弹性的。弹性的指可以作为偏好设置而不是要求。一个Job的启动可以延迟到前一个Job结束，一个Job只能运行在一个cell中。
每个task映射到运行着容器的Linux进程集合中。绝大部分的Borg xxx不运行在虚拟机上，因为我们不想承担硬件虚拟化的巨大开销。并且，这个系统是在我们xxx没有支持虚拟化的硬件。
Task也有它的属性，比如资源需求和它在job中的索引。同一个job中的大多数task有着相同的属性，但也可以被xxx，例如通过命令行参数。每个资源维度（CPU核数，RAM，硬盘空间，硬盘读写速率，TCP端口等）都被独立地指定。Borg程序为了减少对运行时环境的依赖，都采用静态链接，并且被组织成由二进制程序和数据文件组成的包，它们的安装都可以xxx Borg。
用户通过调用RPC来操作jobs，通常通过命令行工具，其他Borg job或是监视系统来完成。大多数job的描述通过xxx配置语言BCI完成。BCI是GCL的变种，它会生成protobuf文件并通过Borg指定的关键字来拓展。GCL提供lambda函数来进行计算，并且被应用用来调整配置和环境。有数万的BCL文件超过1k行，因此我们已经有了超过1千万行的BCL。Borg job的配置和Aurora配2置文件有很多相同之处。
用户可以通过向Borg推送一份新的job配置文件来更改一个正在运行当中的job中的所有task，并且命令Borg更新有新指示的所有任务。这些操作都被视为是一种轻量级的，非原子性的事务，那么当然它们在被关闭（提交）之前也可以轻易撤销。xxxxxxxx一句。
一些task的更新操作（例如推送一个新的二进制文件）总是会触发重启，一些（例如对资源的需求数增长或改变了常量）会使得task不再适应于当前的机器，然后导致它被停止然后重新调度，还有一些（例如更改优先级）总是可以无需重启或移动而被完成。
Task可以请求在被kill之前通过 Unix SIGTERM信号机制得到通知，从而有时间完成扫尾，保存状态，结束当前正在执行的请求并拒绝新请求等操作。xxxxxxxx一句。

2.4 Allocs
例如MapReduce的master上的task比worker节点上的任务优先级稍高一些，为的就是提高master的可靠性。优先级直接反映了cell中正在运行或者正在等待的job的重要程度。Quota被用于调度哪个job来xxx。在一个给定的优先级的一段时间内（通常是数月），quota用一个包含资源数的向量（CPU，RAM，硬盘灯）来表示——资源数置顶了一个用户job某时可以请求的最大资源数。
